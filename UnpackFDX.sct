<scriptlet>
<implements type="Automation" id="dispatcher">
    <property name="PluginEvent"><get/></property>
    <property name="PluginDescription"><get/></property>
    <property name="PluginFileFilters"><get/></property>
    <property name="PluginIsAutomatic"><get/></property>
    <method name="PluginOnEvent"/>
    <method name="UnpackFile"/>
    <method name="PackFile"/>
</implements>

<script language="JScript">

/**
 * @file UnpackFDX.sct
 * @description WinMerge plugin to unpack Final Draft (.fdx) files for comparison.
 * It extracts the screenplay content into a formatted, readable plain text file.
 */

// Global File System Object
var fso = new ActiveXObject("Scripting.FileSystemObject");

// Tells WinMerge the event type.
function get_PluginEvent() {
    return "FILE_PACK_UNPACK";
}

// Returns the description of the plugin
function get_PluginDescription() {
    return "Unpacks Final Draft (.fdx) files into plain text.";
}

// Tells WinMerge to use this plugin for files ending in .fdx
function get_PluginFileFilters() {
    return "\\.fdx$";
}

// Tells WinMerge this is an automatic unpacker plugin
function get_PluginIsAutomatic() {
    return true;
}

// A required function that WinMerge calls for certain events.
function PluginOnEvent(eventType, obj) {
    // This function is required by WinMerge but can be left empty.
}

// A required function for repacking files. We only unpack, so it returns false.
function PackFile(fileSrc, fileDst, pbChanged, pSubcode) {
    return false;
}

/**
 * The main function that WinMerge calls to unpack a file.
 * This function iterates through the main content nodes of the FDX file.
 */
function UnpackFile(fileSrc, fileDst, pbChanged, pSubcode) {
    var fo = fso.CreateTextFile(fileDst, true, true); // Create destination file as Unicode
    var xmlDoc = new ActiveXObject("MSXML2.DOMDocument");
    xmlDoc.async = false;
    xmlDoc.preserveWhiteSpace = true;
    xmlDoc.load(fileSrc);

    if (xmlDoc.parseError.errorCode !== 0) {
        fo.WriteLine("Error parsing FDX file: " + xmlDoc.parseError.reason);
    } else {
        // Get all top-level children of the <Content> tag
        var contentNodes = xmlDoc.selectNodes("//Content/*");
        
        for (var i = 0; i < contentNodes.length; i++) {
            var node = contentNodes[i];
            
            // Use node.nodeName and make it case-insensitive for safety
            var nodeNameUpper = node.nodeName.toUpperCase();
            
            if (nodeNameUpper === "PARAGRAPH") {
                // Check if this Paragraph node is just a wrapper for DualDialogue
                var dualNode = node.selectSingleNode("DualDialogue"); // Check for a child node
                if (dualNode) {
                    // This is the structure the user has. Process the inner node.
                    processDualDialogue(fo, dualNode);
                } else {
                    // This is a normal paragraph
                    processParagraph(fo, node);
                }
            } else if (nodeNameUpper === "DUALDIALOGUE") {
                // This handles cases where <DualDialogue> is a sibling, not nested
                processDualDialogue(fo, node);
            } else if (nodeNameUpper === "SCRIPTNOTE") {
                // Handle ScriptNotes that are siblings to Paragraphs
                processScriptNote(fo, node, ""); // No indent
            } else {
                // This will log any unexpected node types
                if (node.nodeType === 1) { // 1 == ELEMENT_NODE
                     fo.WriteLine("[SKIPPED UNKNOWN NODE: " + node.nodeName + "]");
                     fo.WriteLine("");
                }
            }
        }
    }

    fo.Close();

    // Signal to WinMerge that the operation was successful
    pbChanged = true;
    pSubcode = 0;

    var result = new ActiveXObject("Scripting.Dictionary");
    result.Add(0, true);
    result.Add(1, pbChanged);
    result.Add(2, pSubcode);
    return result.Items();
}

/**
 * Processes a standard <Paragraph> node and writes its formatted text to the file.
 * @param {object} fo - The file stream object to write to.
 * @param {object} pNode - The XML node for the paragraph.
 */
function processParagraph(fo, pNode) {
    var pType = pNode.getAttribute("Type");
    
    // Get all concatenated text from child <Text> nodes
    var text = getFullParagraphText(pNode);

    // Determine indent level for notes
    var indent = "";

    switch (pType) {
        case "Scene Heading":
        case "Shot":
            fo.WriteLine(text.toUpperCase());
            fo.WriteLine("");
            break;
        case "Action":
            fo.WriteLine(text);
            fo.WriteLine("");
            break;
        case "Character":
            //indent = "    ";
            fo.WriteLine(indent + text.toUpperCase());
            break;
        case "Parenthetical":
            //indent = "    ";
            fo.WriteLine(indent + text);
            break;
        case "Dialogue":
            //indent = "        ";
            fo.WriteLine(indent + text);
            fo.WriteLine("");
            break;
        case "Transition":
            indent = "            ";
            fo.WriteLine(indent + text.toUpperCase());
            fo.WriteLine("");
            break;
        case "General":
            // Check if this "General" paragraph contains *only* a script note
            // If so, the text will be blank, and the note will be handled below.
            if (text) {
                //fo.WriteLine("[NOTE: " + text + "]");
				fo.WriteLine(text);
                fo.WriteLine("");
            }
            break;
        default:
            // Catch-all for any other paragraph types
            if (text) {
                fo.WriteLine("[" + (pType ? pType.toUpperCase() : "UNKNOWN") + ": " + text + "]");
                fo.WriteLine("");
            }
            break;
    }

    // Now, check if this paragraph has a ScriptNote attached
    var noteNode = pNode.selectSingleNode("ScriptNote");
    if (noteNode) {
        processScriptNote(fo, noteNode, indent);
    }
}

/**
 * Processes a <DualDialogue> node and formats its content into two columns.
 * @param {object} fo - The file stream object to write to.
 * @param {object} ddNode - The XML node for the dual dialogue block.
 */
function processDualDialogue(fo, ddNode) {
    fo.WriteLine("");
    fo.WriteLine("--- DUAL DIALOGUE ---");
    
    var paragraphs = ddNode.selectNodes("Paragraph");
    
    if (paragraphs.length >= 4) {
        // *** FIX: Use helper function to get all text ***
        var leftCharText = getFullParagraphText(paragraphs[0]);
        leftCharText = "    " + leftCharText.toUpperCase();

        var leftDialogueText = getFullParagraphText(paragraphs[1]);

        var rightCharText = getFullParagraphText(paragraphs[2]);
        rightCharText = "    " + rightCharText.toUpperCase();
        
        var rightDialogueText = getFullParagraphText(paragraphs[3]);


        function pad(text, width) {
            while (text.length < width) {
                text += " ";
            }
            return text;
        }

        var colWidth = 38;

        // Print character names side-by-side
        fo.WriteLine(pad(leftCharText, colWidth) + rightCharText);

        // Interleave dialogue lines
        var leftLines = leftDialogueText.replace(/\r/g, '').split('\n');
        var rightLines = rightDialogueText.replace(/\r/g, '').split('\n');
        var maxLines = Math.max(leftLines.length, rightLines.length);

        for (var i = 0; i < maxLines; i++) {
            var leftLine = (i < leftLines.length) ? "        " + leftLines[i] : "";
            var rightLine = (i < rightLines.length) ? "        " + rightLines[i] : "";
            
            fo.WriteLine(pad(leftLine, colWidth) + rightLine);
        }
    } else {
        // If the dual dialogue block is malformed, print its contents raw
        fo.WriteLine("[MALFORMED DUAL DIALOGUE BLOCK]");
        for (var k = 0; k < paragraphs.length; k++) {
            var pType = paragraphs[k].getAttribute("Type");
            var text = getFullParagraphText(paragraphs[k]); // Use helper here too
            fo.WriteLine("    [" + (pType ? pType.toUpperCase() : "UNKNOWN") + ": " + text + "]");
        }
    }
    
    fo.WriteLine("--- END DUAL DIALOGUE ---");
    fo.WriteLine("");
}

/**
 * Processes a <ScriptNote> node and formats its content.
 * @param {object} fo - The file stream object to write to.
 * @param {object} noteNode - The XML node for the script note.
 *param {string} indent - The indentation to apply (based on parent).
 */
function processScriptNote(fo, noteNode, indent) {
    // .text gets all inner text, including from <Paragraph><Text>
    var noteText = noteNode.text.replace(/[\r\n\t]+/g, ' ').replace(/\s+/g, ' '); // Get note text and clean it up
    
    // *** FIX: Replaced .trim() with a compatible method ***
    noteText = noteText.replace(/^\s+|\s+$/g, ''); 
    
    if (noteText) {
        fo.WriteLine(indent + "[--- SCRIPT NOTE: " + noteText + " ---]");
        fo.WriteLine("");
    }
}

/**
 * Helper function to get all concatenated text from child <Text> nodes.
 * @param {object} pNode - The parent <Paragraph> node.
 * @returns {string} The combined text.
 */
function getFullParagraphText(pNode) {
    if (!pNode) return "";
    var textNodes = pNode.selectNodes("Text"); // Get all <Text> tags
    var text = "";
    for (var i = 0; i < textNodes.length; i++) {
        // Iterate through all child nodes of the <Text> tag
        var childNodes = textNodes[i].childNodes;
        for (var j = 0; j < childNodes.length; j++) {
            var child = childNodes[j];
            // Check if the node is a text node (nodeType 3)
            // This captures all raw text, including whitespace-only nodes
            if (child.nodeType === 3) { 
                text += child.nodeValue;
            }
        }
    }
    return text;
}

</script>
</scriptlet>

